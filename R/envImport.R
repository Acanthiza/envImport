
#' Decide whether to run a new data retrieval
#'
#' Based on existence of file, time since file was created and/or override:
#' Should a data source be requeried?
#' #'
#' @param dataName Character. Name of home data source. e.g. 'BDBSA' or
#' 'GBIF'. This is used to generate file location.
#' @param timeDiff Numeric. Maximum number of days between getting new updates
#' @param override Logical. Override any results from timeDiff. Would usually
#' be specified globally for an ecosystems run.
#'
#' @return logical
#' @export
#'
#' @examples
#' get_new_data("BDBSA",60,FALSE)
#'
  get_new_data <- function(dataName, timeDiff, override = FALSE) {

    dsFile <- base::file.path("out",dataName,paste0(dataName,".feather"))

    getNewTime <- if(file.exists(dsFile)) {

      base::difftime(base::Sys.time()
                     , base::file.mtime(dsFile)
                     , units = "days"
                     ) > timeDiff

    } else TRUE

    override || getNewTime

  }


#' Get data
#'
#' Import data, running 'get_dataName' to requery original data source,
#' if 'lgl'. Optionally times the query, if timeR exists and is specified.
#'
#' @param dataName Character. Name of home data source. e.g. 'BDBSA' or 'GBIF'.
#' This is used to generate file location.
#' @param lgl Logical. Usually generated by get_new_data
#' @param timer Character. timeR object name, if one exists.
#'
#' @return Data
#' @export
#'
#' @examples
  get_data <- function(dataName,lgl,timer = "extractTimer") {

    dsFile <- base::file.path("out",dataName,paste0(dataName,".feather"))

    dir.create(dirname(dsFile))

    if(lgl) {

      dataFuntion <- paste0("get_",dataName)

      if(exists(timer)) get(timer)$start(dataName)

      temp <- do.call(dataFuntion
                      , args = list(dsFile = dsFile)
                      )

      if(exists(timer)) get(timer)$stop(dataName,comment = paste0(nrow(temp)," records"))

    } else {

      temp <- rio::import(dsFile)

    }

    return(temp)

  }


#' Get data from MS Access
#'
#' Generates an instance of 32-bit R, queries the database 'db_path' to
#' retrieve the table 'db_table' and makes the table available as the object
#' 'table_out'. Copied from https://stackoverflow.com/questions/13070706/how-to-connect-r-with-access-database-in-64-bit-window
#'
#' @param db_path Character. Path to MS Access database.
#' @param db_table Character. Name of table within database.
#' @param table_out Character. Name of object to which the table is assigned.
#'
#' @return Makes the table available as the object 'table_out'.
#' @export
#'
#' @examples
#'  access_query_32(db_path = "path/to/site.accdb", db_table = "sites", table_out = "sites")

#'
  access_query_32 <- function(db_path, db_table = "qryData_RM", table_out = "data_access") {

    # copied from https://stackoverflow.com/questions/13070706/how-to-connect-r-with-access-database-in-64-bit-window

    # variables to make values uniform
    sock_port <- 8642L
    sock_con <- "sv_con"
    ODBC_con <- "a32_con"

    if (file.exists(db_path)) {

      # build ODBC string
      ODBC_str <- local({
        s <- list()
        s$path <- paste0("DBQ=", gsub("(/|\\\\)+", "/", path.expand(db_path)))
        s$driver <- "Driver={Microsoft Access Driver (*.mdb, *.accdb)}"
        s$threads <- "Threads=4"
        s$buffer <- "MaxBufferSize=4096"
        s$timeout <- "PageTimeout=5"
        paste(s, collapse=";")
      })

      # start socket server to transfer data to 32 bit session
      svSocket::startSocketServer(port=sock_port, server.name="access_query_32", local=TRUE)

      # build expression to pass to 32 bit R session
      expr <- "library(svSocket)"
      expr <- c(expr, "library(RODBC)")
      expr <- c(expr, sprintf("%s <- odbcDriverConnect('%s')", ODBC_con, ODBC_str))
      expr <- c(expr, sprintf("if('%1$s' %%in%% sqlTables(%2$s)$TABLE_NAME) {%1$s <- sqlFetch(%2$s, '%1$s')} else {%1$s <- 'table %1$s not found'}", db_table, ODBC_con))
      expr <- c(expr, sprintf("%s <- socketConnection(port=%i)", sock_con, sock_port))
      expr <- c(expr, sprintf("evalServer(%s, %s, %s)", sock_con, table_out, db_table))
      expr <- c(expr, "odbcCloseAll()")
      expr <- c(expr, sprintf("close(%s)", sock_con))
      expr <- paste(expr, collapse=";")

      # launch 32 bit R session and run expressions
      prog <- file.path(R.home(), "bin", "i386", "Rscript.exe")
      system2(prog, args=c("-e", shQuote(expr)), stdout=NULL, wait=TRUE, invisible=TRUE)

      # stop socket server
      svSocket::stopSocketServer(port=sock_port)

      # display table fields
      message("retrieved: ", table_out, " - ", paste(colnames(get(table_out)), collapse=", "))
    } else {
      warning("database not found: ", db_path)
    }
  }


#' Create unified data source
#'
#' @param dataMap Dataframe. Needs to contain a coloumn 'dataSource'. Other
#' columns represent the column names in the unified data source. Row values
#' against each dataSource contain the name of the column in the original data
#' source that should map to the current column name.
#' @param sourceType Character. What type of unified data source is being
#' created. e.g. 'flor' for a floristic data sources, 'lc' for landcover data
#' sources
#'
#' @return single data frame unifying the data from the input dataSource s
#' @export
#'
#' @examples
  import_sources <- function(dataMap, sourceType) {

    temp <- dataMap %>%
      dplyr::select(dataSource,days) %>%
      dplyr::mutate(getNew = map2_lgl(dataSource,days,get_new_data)
                    , getNew = map_lgl(getNew,~if_else(getNewData,getNewData,.))
                    , rawData = map2(source,getNew,get_data)
                    , data = map2(source,rawData,prep_data,namesMap = dataMapFlor)
                    )

    florCombine <- florSource %>%
      dplyr::select(negate(is.list),data) %>%
      tidyr::unnest(cols = c(data)) %>%
      dplyr::select(!matches("^n$"))


    #------florAll--------------

    # Create initial flora data set
    florAll <- florCombine %>%
      dplyr::add_count(lat,long,date,source,name = "siteSR") %>%
      #dplyr::sample_n(100) %>% # TESTING
      add_raster_cell(r) %>%
      dplyr::filter(!is.na(cell)) %>%
      dplyr::mutate(SPECIES = gsub("\\s"," ",SPECIES)
                    , SPECIES = str_squish(SPECIES)
                    #, SPECIES = gsub(" subsp\\."," ssp.",SPECIES)
                    #, SPECIES = enc2utf8(SPECIES)
                    #, SPECIES = gsub(rawToChar(charToRaw("Ã—")),"x",SPECIES)
                    #, SPECIES = if_else(grepl(" ",SPECIES),SPECIES,paste0(SPECIES," sp."))
                    , year = year(date)
                    , month = month(date)
                    , SiteID = paste(source,cell,year,month,sep = "_")
      )


    write_feather(florAll
                  , path("out","florAll.feather")
    )



  }
